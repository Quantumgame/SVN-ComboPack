function p=compute_ge_gi_WNTrain2(p, varargin)
% usage:
% out=compute_ge_gi(out);
% optional second argument for regress method
% out=compute_ge_gi(out, 'regress');
% out=compute_ge_gi(out, 'polyfit');
% inputs:
% out: structure generated by ProcessVCData
% outputs: out structure with ge and gi added in
% note: no outfile is written, need to do that manually
% also, no outfile is read,  need to do that manually
% I should really update this to use outfiles!

%8-26-02
%modified 7-11-06
%compute_ge_gi_A3('regress') to get confidence limits,
%compute_ge_gi_A3('polyfit') to skip them [default]
%8-21-02
%   vs   - holding voltage
%   is   - recorded current at soma
%   ee   - excitatory battery
%   ei   - inhibitory battery
%   er   - leak battery
%   k    - attenuation correction coefficient
%
% uses delta I with a syn correctio:
%Isyn= deltaI - gl*(deltaV)
% uses series pulse estimate for gl
% assume steady state at I(0)
%
%uses raw currents and mean corrected potentials
if nargin==1
    method='polyfit';
elseif nargin ==2
    method=varargin{1};
else error('wrong number of arguments')
end
fprintf('\ncomputing conductances using %s method...', method)
if ~isfield(p, 'A') p.A=1; end
if ~isfield(p, 'Ee') p.Ee=0; end
if ~isfield(p, 'Ei') p.Ei=-85; end
k=p.A;
ee=p.Ee;
ei=p.Ei;

gl=1000/p.meanrin; %gl from all series pulses (global)
%gl=1000./p.prin; %gl from series pulses for each potential (local)

numisis=length(p.isis);
numpotentials=length(p.potentials);

%baseline is in samples
baseline=-p.xlimits(1)*p.samprate/1000;
if baseline<=0
    baseline=50; %baseline is used to extract synaptic currents from raw currents
end

%first compute er from is and vs, using baseline
for isiindex=1:numisis
    
    for pindex=1:numpotentials
        is(:,pindex)=squeeze(p.mMt(isiindex, pindex, :));
        vs(:,pindex)=squeeze(p.correctedV(isiindex, pindex, :));
    end
    
    m=zeros(size(1:baseline)); %do I want to use this here? p.samprate*.001*baseline
    b=m;
    er=m;
    
    %        for i=p.baseline %found this on 021907, apparently was only using last point
    for i=1:baseline
        pp = polyfit(vs(i,:), is(i,:), 1);
        m(i) = pp(1);
        b(i)=pp(2);
        er(i)=-b(i)/m(i);
    end
    er=nanmean(er);
    %gl=mean(m);
    b=nanmean(b);
    p.EREST(isiindex)=er;
end

er=mean(nanmean(p.EREST))        ;


%next, use gl and er to compute is_syn, and regress to get gsyn
datalength=length(p.Mt);
min_num_reps=min(min(min(p.nreps)));
npotentials=length(p.potentials);

for isiindex=1:numisis
    %             rawI=zeros(1, datalength, npotentials); %to use mean currents
    rawI=zeros(min_num_reps, datalength, npotentials); %use all currents
    fprintf('\nisi %d', isiindex);
    for pindex=1:numpotentials
        spoo= pindex;
        
        %correct rmat for current divider
        %         rmat=p.rmat;
        %         rin=p.meanrin;
        %         rs=p.meanrs;
        %         correction_factor=(rs+rin)/rin;
        %rmat=rmat*correction_factor;
        
        rawI(:,:,spoo)=squeeze(p.Mt(isiindex, pindex,1:min_num_reps, :)); %use all currents
        %             rawI(:,:,spoo)=squeeze(p.mMt(findex, aindex, pindex,1, :)); %just use the mean currents
        %             fprintf('\ncompute_ge_gi_A3: not using current divider correction')
        
        rawdeltaI(:,:,spoo) = rawI(:,:,spoo) - repmat(mean(rawI(:,1:p.samprate*.001*baseline,spoo), 2), 1, datalength);
        %                 The line above breaks when using xlimits(1)<0, see above
        %                 at line 55 for the establishing of baseline. This bug
        %                 will need to be fixed. in the meantime I made a
        %                 workaround using default xlimits=[0 250]. mk 7jul2011
        %use mean V
        V(:,spoo)=squeeze(p.correctedV(isiindex, pindex, :));
        
        deltaV(:,spoo) = V(:,spoo) - mean(V(1:p.samprate*.001*baseline,spoo));
        %               %use raw V
        %               V(:,:,spoo)=p.corrected_potentials(pindex)-p.meanrs*rawI(:,:,spoo)/1000;
        %               deltaV(:,:,spoo) = V(:,:,spoo) - repmat(mean(V(:,p.baseline,spoo),2), 1, p.datalength);
    end
    
    for pindex=1:npotentials
        spoo= pindex;
        rawIsyn(:,:,spoo) = rawdeltaI(:,:,spoo) - repmat(gl*(deltaV(:,spoo))',size(rawI, 1),1); %global gl% use mean V
        %                rawIsyn(:,:,spoo) = rawdeltaI(:,:,spoo) - gl*(deltaV(:,:,spoo)); %global gl % use raw V
    end
    
    m=zeros(size(1:p.samprate*.001*baseline));
    b=m;
    R=zeros( length(m),npotentials);
    
    for i=1:datalength
        switch method
            case 'polyfit'
                y=rawIsyn(:,i,:);
                y=reshape(y, prod(size(y)), 1);
                %x=V(:,i,:);%use raw V
                x=repmat(V(i,:), size(rawI, 1), 1);%use mean V
                x=reshape(x, prod(size(x)), 1);
                pp = polyfit(x, y, 1);
                m(i) = pp(1);
                b(i)=pp(2);
                conf(i,:)=[0,0];
            case 'regress'
                y=rawIsyn(:,i,:);
                y=reshape(y, prod(size(y)), 1);
                %x=V(:,i,:);%use raw V
                x=repmat(V(i,:), size(rawI, 1), 1);%use mean V
                x=reshape(x, prod(size(x)), 1);
                [pp,bint,r,rint,stats] = regress(y, [x ones(size(x))], .05);
                %                     [pp,bint,r,rint,stats] = regress(is_del(i,:)', [vs(i,:)' ones(size(vs(i,:)'))], .05);
                m(i) = pp(1);
                b(i)=pp(2);
                conf(i,:)=bint(1,:);
                % R(i,:)=r';
            otherwise error('unrecognized argument')
        end %switch
    end%for
    
    %             fprintf('\nmean,max conf=%.2f, %.2f', mean(conf(:,2)-conf(:,1)),max(conf(:,2)-conf(:,1)))
    
    for i=1:datalength
        gi(i) = (b(i) - (1/k -1) * m(i) * er + m(i)*ee/k)/(k* (ee -ei));
        ge(i) = m(i)/(k^2) - gi(i);
    end
    p.GE(isiindex, :)=ge;
    p.GI(isiindex, :)=gi;
    p.GSYN(isiindex, 1, :)=m;
    p.GSYN(isiindex, 2, :)=b;
    p.GSYNconf(isiindex, :,:)=conf;
end
