function p=compute_ge_gi_NBN(p, varargin)
% usage:
% out=compute_ge_gi(out);
% optional second argument for regress method
% out=compute_ge_gi(out, 'regress');
% out=compute_ge_gi(out, 'polyfit');
% inputs:
% out: structure generated by ProcessVCData
% outputs: out structure with ge and gi added in
% note: no outfile is written, need to do that manually
% also, no outfile is read,  need to do that manually
% I should really update this to use outfiles!

%8-26-02
%modified 7-11-06
%compute_ge_gi_A3('regress') to get confidence limits,
%compute_ge_gi_A3('polyfit') to skip them [default]
%8-21-02
%   vs   - holding voltage
%   is   - recorded current at soma
%   ee   - excitatory battery
%   ei   - inhibitory battery
%   er   - leak battery
%   k    - attenuation correction coefficient
%
% uses delta I with a syn correctio:
%Isyn= deltaI - gl*(deltaV)
% uses series pulse estimate for gl
% assume steady state at I(0)
%
%uses raw currents and mean corrected potentials
fprintf('\ncomputing conductances...')
if nargin==1
    method='polyfit';
elseif nargin ==2
    method=varargin{1};
else error('wrong number of arguments')
end
if ~isfield(p, 'A') p.A=1; end
if ~isfield(p, 'Ee') p.Ee=0; end
if ~isfield(p, 'Ei') p.Ei=-85; end
k=p.A;
ee=p.Ee;
ei=p.Ei;

gl=1000/p.meanrin; %gl from all series pulses (global)
%gl=1000./p.prin; %gl from series pulses for each potential (local)

numfreqs=length(p.freqs);
numamps=length(p.amps);
numpotentials=length(p.potentials);
numbws=length(p.bws);

baseline=-p.xlimits(1);
if baseline==0
    baseline=10; %baseline is used to extract synaptic currents from raw currents
end

%first compute er from is and vs, using baseline
for bwindex=[1:numbws]
    for findex=1:numfreqs
        for aindex=1:numamps
            nr=sum(p.nreps(findex, aindex,bwindex, :));
            if nr>0
                for pindex=1:numpotentials
                    is(:,pindex)=squeeze(p.mM1(findex,aindex, bwindex, pindex,1, :));
                    vs(:,pindex)=squeeze(p.correctedV(findex,aindex, bwindex, pindex, :));
                end

                m=zeros(size(1:baseline)); %do I want to use this here? p.samprate*.001*baseline
                b=m;
                er=m;

                %        for i=p.baseline %found this on 021907, apparently was only using last point
                for i=1:baseline
                    pp = polyfit(vs(i,:), is(i,:), 1);
                    m(i) = pp(1);
                    b(i)=pp(2);
                    er(i)=-b(i)/m(i);
                end
                er=nanmean(er);
                %gl=mean(m);
                b=nanmean(b);
                p.EREST(findex, aindex, bwindex)=er;
            end
        end
    end
end
p.EREST(find(~p.EREST))=nan;
er=mean(nanmean((p.EREST)));


%next, use gl and er to compute is_syn, and regress to get gsyn
datalength=length(p.M1);
min_num_reps=min(min(min(p.nreps(find(p.nreps))))); %exclude stim with 0 reps from min_num_reps
npotentials=length(p.potentials);

for findex=1:numfreqs
    for bwindex=[1:numbws]
        for aindex=1:numamps

            %             rawI=zeros(1, datalength, npotentials); %to use mean currents
            rawI=zeros(min_num_reps, datalength, npotentials); %use all currents
            for pindex=1:numpotentials
                spoo= pindex;
                nr=p.nreps(findex, aindex,bwindex, pindex);
                if nr>0
                    %correct rmat for current divider
                    %         rmat=p.rmat;
                    %         rin=p.meanrin;
                    %         rs=p.meanrs;
                    %         correction_factor=(rs+rin)/rin;
                    %rmat=rmat*correction_factor;

                    rawI(:,:,spoo)=squeeze(p.M1(findex, aindex, bwindex, pindex,1:min_num_reps, :)); %use all currents
                    %             rawI(:,:,spoo)=squeeze(p.mM1(findex, aindex, pindex,1, :)); %just use the mean currents
                    %             fprintf('\ncompute_ge_gi_A3: not using current divider correction')

                    rawdeltaI(:,:,spoo) = rawI(:,:,spoo) - repmat(mean(rawI(:,1:p.samprate*.001*baseline,spoo), 2), 1, datalength);

                    %use mean V
                    V(:,spoo)=squeeze(p.correctedV(findex, aindex, bwindex, pindex, :));

                    deltaV(:,spoo) = V(:,spoo) - mean(V(1:p.samprate*.001*baseline,spoo));
                    %               %use raw V
                    %               V(:,:,spoo)=p.corrected_potentials(pindex)-p.meanrs*rawI(:,:,spoo)/1000;
                    %               deltaV(:,:,spoo) = V(:,:,spoo) - repmat(mean(V(:,p.baseline,spoo),2), 1, p.datalength);
                end
            end

            nr=p.nreps(findex, aindex,bwindex, pindex);
            if nr>0
                for pindex=1:npotentials
                    spoo= pindex;
                    rawIsyn(:,:,spoo) = rawdeltaI(:,:,spoo) - repmat(gl*(deltaV(:,spoo))',size(rawI, 1),1); %global gl% use mean V
                    %                rawIsyn(:,:,spoo) = rawdeltaI(:,:,spoo) - gl*(deltaV(:,:,spoo)); %global gl % use raw V
                end
            end

            m=zeros(size(1:p.samprate*.001*baseline));
            b=m;
            R=zeros( length(m),npotentials);

            if nr>0
%                 fprintf('\nf%d a%d bw%d empty', findex, aindex, bwindex);
%             else
                 fprintf('\nf%d a%d bw%d', findex, aindex, bwindex);

                for i=1:datalength
                    switch method
                        case 'polyfit'
                            y=rawIsyn(:,i,:);
                            y=reshape(y, prod(size(y)), 1);
                            %x=V(:,i,:);%use raw V
                            x=repmat(V(i,:), size(rawI, 1), 1);%use mean V
                            x=reshape(x, prod(size(x)), 1);
                            pp = polyfit(x, y, 1);
                            m(i) = pp(1);
                            b(i)=pp(2);
                            conf(i,:)=[0,0];
                        case 'regress'
                            y=rawIsyn(:,i,:);
                            y=reshape(y, prod(size(y)), 1);
                            %x=V(:,i,:);%use raw V
                            x=repmat(V(i,:), size(rawI, 1), 1);%use mean V
                            x=reshape(x, prod(size(x)), 1);
                            [pp,bint,r,rint,stats] = regress(y, [x ones(size(x))], .05);
                            %                     [pp,bint,r,rint,stats] = regress(is_del(i,:)', [vs(i,:)' ones(size(vs(i,:)'))], .05);
                            m(i) = pp(1);
                            b(i)=pp(2);
                            conf(i,:)=bint(1,:);
                            % R(i,:)=r';
                        otherwise error('unrecognized argument')
                    end %switch
                end%for


                %             fprintf('\nmean,max conf=%.2f, %.2f', mean(conf(:,2)-conf(:,1)),max(conf(:,2)-conf(:,1)))

                for i=1:datalength
                    gi(i) = (b(i) - (1/k -1) * m(i) * er + m(i)*ee/k)/(k* (ee -ei));
                    ge(i) = m(i)/(k^2) - gi(i);
                end
                p.GE(findex, aindex, bwindex, :)=ge;
                p.GI(findex, aindex, bwindex, :)=gi;
                p.GSYN(findex, aindex, bwindex, 1, :)=m;
                p.GSYN(findex, aindex,bwindex, 2, :)=b;
                p.GSYNconf(findex, aindex, bwindex, :,:)=conf;
            end
        end
        end
    end
end